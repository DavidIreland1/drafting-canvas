(function webpackUniversalModuleDefinition(root, factory) {
	if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();
	else if (typeof define === 'function' && define.amd) define([], factory);
	else if (typeof exports === 'object') exports['reducer'] = factory();
	else root['reducer'] = factory();
})(global, function () {
	return /******/ (() => {
		// webpackBootstrap
		/******/ 'use strict';
		/******/ // The require scope
		/******/ var __webpack_require__ = {};
		/******/
		/************************************************************************/
		/******/ /* webpack/runtime/define property getters */
		/******/ (() => {
			/******/ // define getter functions for harmony exports
			/******/ __webpack_require__.d = (exports, definition) => {
				/******/ for (var key in definition) {
					/******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
						/******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
						/******/
					}
					/******/
				}
				/******/
			};
			/******/
		})();
		/******/
		/******/ /* webpack/runtime/hasOwnProperty shorthand */
		/******/ (() => {
			/******/ __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
			/******/
		})();
		/******/
		/******/ /* webpack/runtime/make namespace object */
		/******/ (() => {
			/******/ // define __esModule on exports
			/******/ __webpack_require__.r = (exports) => {
				/******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
					/******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
					/******/
				}
				/******/ Object.defineProperty(exports, '__esModule', { value: true });
				/******/
			};
			/******/
		})();
		/******/
		/************************************************************************/
		var __webpack_exports__ = {};
		// ESM COMPAT FLAG
		__webpack_require__.r(__webpack_exports__);

		// EXPORTS
		__webpack_require__.d(__webpack_exports__, {
			default: () => /* binding */ reducers,
		}); // CONCATENATED MODULE: ./reducers/creation.ts

		var __read =
			(undefined && undefined.__read) ||
			function (o, n) {
				var m = typeof Symbol === 'function' && o[Symbol.iterator];
				if (!m) return o;
				var i = m.call(o),
					r,
					ar = [],
					e;
				try {
					while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
				} catch (error) {
					e = { error: error };
				} finally {
					try {
						if (r && !r.done && (m = i['return'])) m.call(i);
					} finally {
						if (e) throw e.error;
					}
				}
				return ar;
			};
		/* harmony default export */ const creation = {
			overwrite: function (state, props) {
				Object.entries(props.payload.state).forEach(function (_a) {
					var _b = __read(_a, 2),
						key = _b[0],
						value = _b[1];
					state[key] = value;
				});
			},
			addUser: function (state, props) {
				var _a = props.payload,
					user_id = _a.user_id,
					label = _a.label;
				state.views.push({ id: user_id, label: label, x: 0, y: 0, scale: 1 });
				state.cursors.push({ id: user_id, label: label, x: 0, y: 0, rotation: 0, type: 'none', pressed: false });
			},
		}; // CONCATENATED MODULE: ./reducers/cursor.ts

		/* harmony default export */ const cursor = {
			view: function (state, props) {
				var _a = props.payload,
					id = _a.id,
					delta_x = _a.delta_x,
					delta_y = _a.delta_y,
					delta_scale = _a.delta_scale,
					cursor_x = _a.cursor_x,
					cursor_y = _a.cursor_y;
				var view = state.views.find(function (view) {
					return id === view.id;
				});
				if (delta_x) view.x += delta_x;
				if (delta_y) view.y += delta_y;
				if (delta_scale) view.scale += delta_scale;
				var cursor = state.cursors.find(function (cursor) {
					return id === cursor.id;
				});
				if (cursor_x) cursor.x = cursor_x;
				if (cursor_y) cursor.y = cursor_y;
			},
			cursor: function (state, props) {
				var _a = props.payload,
					id = _a.id,
					x = _a.x,
					y = _a.y,
					rotation = _a.rotation,
					type = _a.type;
				var cursor = state.cursors.find(function (cursor) {
					return id === cursor.id;
				});
				if (!cursor) return;
				if (x) cursor.x = x;
				if (y) cursor.y = y;
				if (rotation) cursor.rotation = rotation;
				if (type) cursor.type = type;
			},
		}; // CONCATENATED MODULE: ./components/elements/element.ts

		// import Defaults from './../../defaults';
		// const { line, box_size, highlight_color } = Defaults;
		var Element = /** @class */ (function () {
			function Element() {}
			Element.draw = function (element, context, cursor) {
				return;
			};
			Element.fill = function (element, context) {
				element.fill.forEach(function (fill) {
					context.fillStyle = fill.color;
					context.fill();
				});
			};
			Element.stroke = function (element, context) {
				element.fill.forEach(function (fill) {
					context.fillStyle = fill.color;
					context.fill();
				});
			};
			Element.resize = function (element, position, last_position) {
				return;
			};
			Element.stretch = function (element, position, last_position) {
				return;
			};
			Element.outline = function (element, context, color, line) {
				return;
			};
			Element.onScreen = function (element, screen) {
				var bounds = this.positiveBound(element);
				return !(bounds.x > screen.x2 || bounds.y > screen.y2 || bounds.x + bounds.width < screen.x1 || bounds.y + bounds.height < screen.y1);
			};
			Element.highlight = function (element, context, cursor, highlight, line, box) {
				this.outline(element, context, highlight, line);
				var action = undefined;
				if (this.drawBound(element, context, cursor, highlight, line)) action = 'stretch';
				if (this.drawRotate(element, context, cursor, box)) action = 'rotate';
				if (this.drawResize(element, context, cursor, highlight, line, box)) action = 'resize';
				return action ? { action: action, element: element } : undefined;
			};
			Element.insideBound = function (element, context, cursor) {
				var bounds = this.bound(element);
				var center = this.center(element);
				context.translate(center.x, center.y);
				context.rotate(element.rotation);
				context.beginPath();
				context.rect(-bounds.width / 2, -bounds.height / 2, bounds.width, bounds.height);
				context.rotate(-element.rotation);
				context.translate(-center.x, -center.y);
				return context.isPointInPath(cursor.x, cursor.y);
			};
			Element.drawBound = function (element, context, cursor, color, line) {
				var bounds = this.bound(element);
				var center = this.center(element);
				context.translate(center.x, center.y);
				context.rotate(element.rotation);
				context.strokeStyle = color;
				context.beginPath();
				context.rect(-bounds.width / 2, -bounds.height / 2, bounds.width, bounds.height);
				context.lineWidth = line * 2;
				var hov = context.isPointInStroke(cursor.x, cursor.y);
				context.lineWidth = line;
				context.stroke();
				context.rotate(-element.rotation);
				context.translate(-center.x, -center.y);
				return hov;
			};
			Element.drawResize = function (element, context, cursor, color, line, box_size) {
				var bounds = this.bound(element);
				var center = this.center(element);
				context.translate(center.x, center.y);
				context.rotate(element.rotation);
				if (Math.abs(bounds.width) + Math.abs(bounds.height) > box_size * 4) {
					bounds.x = -bounds.width / 2;
					bounds.y = -bounds.height / 2;
					context.fillStyle = 'white';
					context.strokeStyle = color;
					context.lineWidth = line;
					context.beginPath();
					this.boxes(element.id, bounds, box_size).forEach(function (square) {
						return context.rect(square.x, square.y, square.width, square.height);
					});
					context.fill();
					context.stroke();
				}
				context.rotate(-element.rotation);
				context.translate(-center.x, -center.y);
				return context.isPointInPath(cursor.x, cursor.y);
			};
			Element.drawRotate = function (element, context, cursor, box_size) {
				var bounds = this.bound(element);
				var center = this.center(element);
				context.translate(center.x, center.y);
				context.rotate(element.rotation);
				bounds.x = -bounds.width / 2 - Math.sign(bounds.width) * box_size;
				bounds.y = -bounds.height / 2 - Math.sign(bounds.height) * box_size;
				bounds.width += Math.sign(bounds.width) * box_size * 2;
				bounds.height += Math.sign(bounds.height) * box_size * 2;
				context.beginPath();
				this.boxes(element.id, bounds, box_size * 2).forEach(function (square) {
					return context.rect(square.x, square.y, square.width, square.height);
				});
				context.rotate(-element.rotation);
				context.translate(-center.x, -center.y);
				return context.isPointInPath(cursor.x, cursor.y);
			};
			Element.center = function (element) {
				var bounds = this.bound(element);
				return {
					x: bounds.x + bounds.width / 2,
					y: bounds.y + bounds.height / 2,
				};
			};
			Element.bound = function (element) {
				return {
					x: element.x,
					y: element.y,
					width: element.width,
					height: element.height,
				};
			};
			Element.getFill = function (element) {
				return element.fill;
			};
			Element.setFill = function (element, colors) {
				element.fill.forEach(function (fill) {
					if (fill.color === colors.from) fill.color = colors.to;
				});
			};
			Element.positiveBound = function (element) {
				var bounds = this.bound(element);
				return {
					x: Math.min(bounds.x, bounds.x + bounds.width),
					y: Math.min(bounds.y, bounds.y + bounds.height),
					width: Math.abs(bounds.width),
					height: Math.abs(bounds.height),
				};
			};
			Element.move = function (element, position, last_position) {
				element.x += position.x - last_position.x;
				element.y += position.y - last_position.y;
				// element.x = Math.round(element.x * 100) / 100;
				// element.y = Math.round(element.y * 100) / 100;
			};
			Element.rotatePoint = function (position, center, rotation) {
				return {
					x: (position.x - center.x) * Math.cos(rotation) - (position.y - center.y) * Math.sin(rotation) + center.x,
					y: (position.x - center.x) * Math.sin(rotation) + (position.y - center.y) * Math.cos(rotation) + center.y,
				};
			};
			Element.rotate = function (element, theta) {
				element.rotation += theta;
			};
			Element.boxes = function (id, bounds, box_size) {
				return [
					{
						id: id,
						x: bounds.x - box_size,
						y: bounds.y - box_size,
						width: box_size * 2,
						height: box_size * 2,
					},
					{
						id: id,
						x: bounds.x + bounds.width - box_size,
						y: bounds.y - box_size,
						width: box_size * 2,
						height: box_size * 2,
					},
					{
						id: id,
						x: bounds.x - box_size,
						y: bounds.y + bounds.height - box_size,
						width: box_size * 2,
						height: box_size * 2,
					},
					{
						id: id,
						x: bounds.x + bounds.width - box_size,
						y: bounds.y + bounds.height - box_size,
						width: box_size * 2,
						height: box_size * 2,
					},
				];
			};
			return Element;
		})();
		/* harmony default export */ const elements_element = Element; // CONCATENATED MODULE: ./components/elements/circle.ts

		var __extends =
			(undefined && undefined.__extends) ||
			(function () {
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({ __proto__: [] } instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
						};
					return extendStatics(d, b);
				};
				return function (d, b) {
					if (typeof b !== 'function' && b !== null) throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				};
			})();

		var Circle = /** @class */ (function (_super) {
			__extends(Circle, _super);
			function Circle() {
				return (_super !== null && _super.apply(this, arguments)) || this;
			}
			Circle.draw = function (circle, context, cursor) {
				context.beginPath();
				context.arc(circle.x, circle.y, Math.abs(circle.radius), circle.start_angle, circle.end_angle, circle.counter_clockwise);
				this.fill(circle, context);
				this.stroke(circle, context);
				return context.isPointInPath(cursor.x, cursor.y);
			};
			Circle.outline = function (circle, context, color, line_width) {
				context.strokeStyle = color;
				context.lineWidth = line_width;
				context.beginPath();
				context.arc(circle.x, circle.y, circle.radius, circle.start_angle, circle.end_angle);
				context.stroke();
			};
			Circle.bound = function (circle) {
				return {
					x: circle.x - circle.radius,
					y: circle.y - circle.radius,
					width: circle.radius * 2,
					height: circle.radius * 2,
				};
			};
			Circle.resize = function (ellipse, position, last_position) {
				var center = this.center(ellipse);
				var opposite = {
					x: center.x - (last_position.x - center.x),
					y: center.y - (last_position.y - center.y),
				};
				var new_center = {
					x: (opposite.x + position.x) / 2,
					y: (opposite.y + position.y) / 2,
				};
				var new_opposite = rotatePoint(opposite, new_center, -ellipse.rotation);
				var new_position = rotatePoint(position, new_center, -ellipse.rotation);
				ellipse.x = new_center.x;
				ellipse.y = new_center.y;
				ellipse.radius = Math.max(new_position.x - new_opposite.x, new_position.y - new_opposite.y) / 2;
			};
			return Circle;
		})(elements_element);
		/* harmony default export */ const circle = Circle; // CONCATENATED MODULE: ./components/elements/ellipse.ts

		var ellipse_extends =
			(undefined && undefined.__extends) ||
			(function () {
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({ __proto__: [] } instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
						};
					return extendStatics(d, b);
				};
				return function (d, b) {
					if (typeof b !== 'function' && b !== null) throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				};
			})();

		var Ellipse = /** @class */ (function (_super) {
			ellipse_extends(Ellipse, _super);
			function Ellipse() {
				return (_super !== null && _super.apply(this, arguments)) || this;
			}
			Ellipse.draw = function (ellipse, context, cursor) {
				context.beginPath();
				context.ellipse(ellipse.x, ellipse.y, Math.abs(ellipse.radius_x), Math.abs(ellipse.radius_y), ellipse.rotation, ellipse.start_angle, ellipse.end_angle, ellipse.counter_clockwise);
				this.fill(ellipse, context);
				this.stroke(ellipse, context);
				return context.isPointInPath(cursor.x, cursor.y);
			};
			Ellipse.outline = function (ellipse, context, color, line_width) {
				context.strokeStyle = color;
				context.lineWidth = line_width;
				context.beginPath();
				context.ellipse(ellipse.x, ellipse.y, Math.abs(ellipse.radius_x), Math.abs(ellipse.radius_y), ellipse.rotation, ellipse.start_angle, ellipse.end_angle, ellipse.counter_clockwise);
				context.stroke();
			};
			Ellipse.center = function (ellipse) {
				return {
					x: ellipse.x,
					y: ellipse.y,
				};
			};
			Ellipse.bound = function (ellipse) {
				return {
					x: ellipse.x - ellipse.radius_x,
					y: ellipse.y - ellipse.radius_y,
					width: ellipse.radius_x * 2,
					height: ellipse.radius_y * 2,
				};
			};
			Ellipse.resize = function (ellipse, position, last_position) {
				var center = this.center(ellipse);
				var opposite = {
					x: center.x - (last_position.x - center.x),
					y: center.y - (last_position.y - center.y),
				};
				var new_center = {
					x: (opposite.x + position.x) / 2,
					y: (opposite.y + position.y) / 2,
				};
				var new_opposite = rotatePoint(opposite, new_center, -ellipse.rotation);
				var new_position = rotatePoint(position, new_center, -ellipse.rotation);
				ellipse.x = new_center.x;
				ellipse.y = new_center.y;
				ellipse.radius_x = (new_position.x - new_opposite.x) / 2;
				ellipse.radius_y = (new_position.y - new_opposite.y) / 2;
			};
			return Ellipse;
		})(elements_element);
		/* harmony default export */ const ellipse = Ellipse; // CONCATENATED MODULE: ./components/elements/group.ts

		var group_extends =
			(undefined && undefined.__extends) ||
			(function () {
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({ __proto__: [] } instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
						};
					return extendStatics(d, b);
				};
				return function (d, b) {
					if (typeof b !== 'function' && b !== null) throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				};
			})();
		var group_read =
			(undefined && undefined.__read) ||
			function (o, n) {
				var m = typeof Symbol === 'function' && o[Symbol.iterator];
				if (!m) return o;
				var i = m.call(o),
					r,
					ar = [],
					e;
				try {
					while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
				} catch (error) {
					e = { error: error };
				} finally {
					try {
						if (r && !r.done && (m = i['return'])) m.call(i);
					} finally {
						if (e) throw e.error;
					}
				}
				return ar;
			};
		var __spreadArray =
			(undefined && undefined.__spreadArray) ||
			function (to, from) {
				for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
				return to;
			};

		var Group = /** @class */ (function (_super) {
			group_extends(Group, _super);
			function Group() {
				return (_super !== null && _super.apply(this, arguments)) || this;
			}
			Group.draw = function (group, context, cursor) {
				var center = this.center(group);
				context.translate(center.x, center.y);
				context.rotate(group.rotation);
				context.translate(-center.x, -center.y);
				var hovering = __spreadArray([], group_read(group.elements))
					.reverse()
					.filter(function (element) {
						return elements_elements[element.type].draw(element, context, cursor);
					});
				context.translate(center.x, center.y);
				context.rotate(-group.rotation);
				context.translate(-center.x, -center.y);
				return hovering.length > 0;
			};
			Group.bound = function (group) {
				var positions = group.elements.map(function (element) {
					return elements_elements[element.type].bound(element);
				});
				var min_x = positions.reduce(function (x, position) {
					return Math.min(x, position.x);
				}, Number.MAX_SAFE_INTEGER);
				var min_y = positions.reduce(function (y, position) {
					return Math.min(y, position.y);
				}, Number.MAX_SAFE_INTEGER);
				return {
					x: min_x,
					y: min_y,
					width:
						positions.reduce(function (x, position) {
							return Math.max(x, position.x + position.width);
						}, Number.MIN_SAFE_INTEGER) - min_x,
					height:
						positions.reduce(function (y, position) {
							return Math.max(y, position.y + position.height);
						}, Number.MIN_SAFE_INTEGER) - min_y,
				};
			};
			Group.outline = function (group, context, color, line_width) {
				var bounds = this.bound(group);
				var center = this.center(group);
				context.translate(center.x, center.y);
				context.rotate(group.rotation);
				context.strokeStyle = color;
				context.lineWidth = line_width;
				context.beginPath();
				context.rect(-bounds.width / 2, -bounds.height / 2, bounds.width, bounds.height);
				context.stroke();
				context.rotate(-group.rotation);
				context.translate(-center.x, -center.y);
			};
			// static highlight(group, context: CanvasRenderingContext2D, cursor, color: string, line_width: number, box_size: number): boolean {
			// 	if (group.selected) super.highlight(group, context, cursor, color, line_width, box_size);
			// 	// group.elements.forEach((element) => {
			// 	// 	if (element.selected || element.type === 'group') Elements[element.type].highlight(element, context, color, line_width, box_size);
			// 	// });
			// 	return undefined;
			// }
			Group.getFill = function (group) {
				return group.elements
					.map(function (element) {
						return elements_elements[element.type].getFill(element);
					})
					.flat();
			};
			Group.setFill = function (group, colors) {
				group.elements.map(function (element) {
					return elements_elements[element.type].setFill(element, colors);
				});
			};
			Group.move = function (group, position, last_position) {
				group.elements
					.filter(function (element) {
						return !element.selected;
					})
					.forEach(function (element) {
						elements_elements[element.type].move(element, position, last_position);
					});
			};
			Group.resize = function (group, position, last_position) {
				// const group_center = this.center(group);
				// const opposite = {
				// 	x: group_center.x - (position.x - group_center.x),
				// 	y: group_center.y - (position.y - group_center.y),
				// };
				// const last_opposite = {
				// 	x: group_center.x - (last_position.x - group_center.x),
				// 	y: group_center.y - (last_position.y - group_center.y),
				// };
				group.elements.forEach(function (element) {
					// const center = Elements[element.type].center(element);
					// const position = {
					// 	x: center.x - (opposite.x - center.x),
					// 	y: center.y - (opposite.y - center.y),
					// };
					// const last_position = {
					// 	x: center.x - (last_opposite.x - center.x),
					// 	y: center.y - (last_opposite.y - center.y),
					// };
					elements_elements[element.type].resize(element, position, last_position);
				});
			};
			return Group;
		})(elements_element);
		/* harmony default export */ const group = Group; // CONCATENATED MODULE: ./components/elements/rectangle.ts

		var rectangle_extends =
			(undefined && undefined.__extends) ||
			(function () {
				var extendStatics = function (d, b) {
					extendStatics =
						Object.setPrototypeOf ||
						({ __proto__: [] } instanceof Array &&
							function (d, b) {
								d.__proto__ = b;
							}) ||
						function (d, b) {
							for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
						};
					return extendStatics(d, b);
				};
				return function (d, b) {
					if (typeof b !== 'function' && b !== null) throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
				};
			})();

		var Rectangle = /** @class */ (function (_super) {
			rectangle_extends(Rectangle, _super);
			function Rectangle() {
				return (_super !== null && _super.apply(this, arguments)) || this;
			}
			Rectangle.draw = function (rectangle, context, cursor) {
				var center = this.center(rectangle);
				context.fillStyle = rectangle.color;
				context.translate(center.x, center.y);
				context.rotate(rectangle.rotation);
				context.beginPath();
				context.rect(-rectangle.width / 2, -rectangle.height / 2, rectangle.width, rectangle.height);
				this.fill(rectangle, context);
				this.stroke(rectangle, context);
				context.rotate(-rectangle.rotation);
				context.translate(-center.x, -center.y);
				return context.isPointInPath(cursor.x, cursor.y);
			};
			Rectangle.outline = function (rectangle, context, color, line_width) {
				var center = this.center(rectangle);
				context.strokeStyle = color;
				context.lineWidth = line_width;
				context.translate(center.x, center.y);
				context.rotate(rectangle.rotation);
				context.beginPath();
				context.rect(-rectangle.width / 2, -rectangle.height / 2, rectangle.width, rectangle.height);
				context.stroke();
				context.rotate(-rectangle.rotation);
				context.translate(-center.x, -center.y);
			};
			Rectangle.bound = function (rectangle) {
				return {
					x: rectangle.x,
					y: rectangle.y,
					width: rectangle.width,
					height: rectangle.height,
				};
			};
			Rectangle.resize = function (rectangle, position, last_position) {
				var center = this.center(rectangle);
				var opposite = {
					x: center.x - (last_position.x - center.x),
					y: center.y - (last_position.y - center.y),
				};
				var new_center = {
					x: (opposite.x + position.x) / 2,
					y: (opposite.y + position.y) / 2,
				};
				var new_opposite = rotatePoint(opposite, new_center, -rectangle.rotation);
				var new_position = rotatePoint(position, new_center, -rectangle.rotation);
				rectangle.x = new_opposite.x;
				rectangle.y = new_opposite.y;
				rectangle.width = new_position.x - new_opposite.x;
				rectangle.height = new_position.y - new_opposite.y;
			};
			Rectangle.stretch = function (rectangle, position, last_position) {
				var center = this.center(rectangle);
				var opposite = {
					x: center.x - (last_position.x - center.x),
					y: center.y - (last_position.y - center.y),
				};
				var new_center = {
					x: (opposite.x + position.x) / 2,
					y: (opposite.y + position.y) / 2,
				};
				var new_opposite = rotatePoint(opposite, new_center, -rectangle.rotation);
				var new_position = rotatePoint(position, new_center, -rectangle.rotation);
				// rectangle.x = new_opposite.x;
				rectangle.y = new_opposite.y;
				// rectangle.width = new_position.x - new_opposite.x;
				rectangle.height = new_position.y - new_opposite.y;
			};
			return Rectangle;
		})(elements_element);
		/* harmony default export */ const rectangle = Rectangle; // CONCATENATED MODULE: ./components/elements/elements.ts

		/* harmony default export */ const elements_elements = {
			circle: circle,
			ellipse: ellipse,
			group: group,
			rectangle: rectangle,
		};
		function flatten(elements) {
			return elements.reduce(function (all, element) {
				return all.concat(element.type === 'group' ? flatten(element.elements) : [], [element]);
			}, []);
		}
		function forEachElement(elements, callback) {
			elements.forEach(function (element, index, array) {
				callback(element, index, array);
				if (element.type === 'group') {
					forEachElement(element.elements, callback);
				}
			});
		}
		function selected(elements) {
			return flatten(elements).filter(function (element) {
				return element.selected;
			});
		} // CONCATENATED MODULE: ./utils/utils.ts

		function round(number, decimals) {
			return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
		} // CONCATENATED MODULE: ./reducers/modifications/interactions.ts

		var interactions_read =
			(undefined && undefined.__read) ||
			function (o, n) {
				var m = typeof Symbol === 'function' && o[Symbol.iterator];
				if (!m) return o;
				var i = m.call(o),
					r,
					ar = [],
					e;
				try {
					while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
				} catch (error) {
					e = { error: error };
				} finally {
					try {
						if (r && !r.done && (m = i['return'])) m.call(i);
					} finally {
						if (e) throw e.error;
					}
				}
				return ar;
			};

		var interactions = {
			resize: function (state, props) {
				var _a = props.payload,
					id = _a.id,
					position = _a.position,
					last_position = _a.last_position;
				var selected = state.elements.filter(function (element) {
					return element.selected;
				});
				selected.forEach(function (element) {
					return elements_elements[element.type].resize(element, position, last_position);
				});
			},
			rotate: function (state, props) {
				var _a = props.payload,
					user_id = _a.user_id,
					id = _a.id,
					position = _a.position,
					last_position = _a.last_position;
				var selected = state.elements.filter(function (element) {
					return element.selected;
				});
				var target = flatten(state.elements).find(function (element) {
					return id === element.id;
				});
				var center = elements_elements[target.type].center(target);
				var rotation = Math.atan2(center.y - position.y, center.x - position.x) - Math.atan2(center.y - last_position.y, center.x - last_position.x);
				selected.forEach(function (element) {
					return elements_elements[element.type].rotate(element, rotation);
				});
				var cursor = state.cursors.find(function (cursor) {
					return user_id === cursor.id;
				});
				cursor.rotation += rotation;
			},
			stretch: function (state, props) {
				var _a = props.payload,
					id = _a.id,
					position = _a.position,
					last_position = _a.last_position;
				var selected = state.elements.filter(function (element) {
					return element.selected;
				});
				selected.forEach(function (element) {
					return elements_elements[element.type].stretch(element, position, last_position);
				});
			},
			propertyRelative: function (state, props) {
				selected(state.elements).forEach(function (element) {
					Object.entries(props.payload).forEach(function (_a) {
						var _b = interactions_read(_a, 2),
							key = _b[0],
							value = _b[1];
						element[key] += round(value, 2);
					});
				});
			},
			move: function (state, props) {
				var _a = props.payload,
					position = _a.position,
					last_position = _a.last_position;
				selected(state.elements).forEach(function (element) {
					return elements_elements[element.type].move(element, position, last_position);
				});
			},
		};
		/* harmony default export */ const modifications_interactions = interactions;
		var interaction_types = Object.keys(inter); // CONCATENATED MODULE: ./reducers/modifications/properties.ts

		var properties_read =
			(undefined && undefined.__read) ||
			function (o, n) {
				var m = typeof Symbol === 'function' && o[Symbol.iterator];
				if (!m) return o;
				var i = m.call(o),
					r,
					ar = [],
					e;
				try {
					while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
				} catch (error) {
					e = { error: error };
				} finally {
					try {
						if (r && !r.done && (m = i['return'])) m.call(i);
					} finally {
						if (e) throw e.error;
					}
				}
				return ar;
			};

		/* harmony default export */ const properties = {
			addFill: function (state, props) {
				selected(state.elements).forEach(function (element) {
					element.fill.push(props.payload);
				});
			},
			setColor: function (state, props) {
				selected(state.elements).forEach(function (element) {
					elements_elements[element.type].setFill(element, props.payload);
				});
			},
			property: function (state, props) {
				selected(state.elements).forEach(function (element) {
					Object.entries(props.payload).forEach(function (_a) {
						var _b = properties_read(_a, 2),
							key = _b[0],
							value = _b[1];
						element[key] = round(value, 2);
					});
				});
			},
			deleteSelected: function (state) {
				forEachElement(state.elements, function (element, i, elements) {
					if (element.selected === true) elements.splice(i, 1);
				});
			},
		}; // CONCATENATED MODULE: ./reducers/modifications/modifications.ts

		var __assign =
			(undefined && undefined.__assign) ||
			function () {
				__assign =
					Object.assign ||
					function (t) {
						for (var s, i = 1, n = arguments.length; i < n; i++) {
							s = arguments[i];
							for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
						}
						return t;
					};
				return __assign.apply(this, arguments);
			};

		var modifications = __assign(__assign({}, modifications_inter), properties);
		/* harmony default export */ const modifications_modifications = modifications;
		var modification_types = Object.keys(modifications); // CONCATENATED MODULE: ./reducers/tools.ts

		/* harmony default export */ const tools = {
			hover: function (state, props) {
				state.elements.find(function (element) {
					return element.id === props.payload.id;
				}).hover = true;
			},
			unhover: function (state, props) {
				state.elements.find(function (element) {
					return element.id === props.payload.id;
				}).hover = false;
			},
			select: function (state, props) {
				var element = flatten(state.elements).find(function (element) {
					return element.id === props.payload.id;
				});
				if (element) element.selected = true;
			},
			selectOnly: function (state, props) {
				flatten(state.elements).forEach(function (element) {
					return (element.selected = props.payload.select.includes(element.id));
				});
			},
			unselect: function (state, props) {
				var element = flatten(state.elements).find(function (element) {
					return element.id === props.payload.id;
				});
				if (element) element.selected = false;
			},
			selectAll: function (state) {
				flatten(state.elements).forEach(function (element) {
					return (element.selected = true);
				});
			},
			unselectAll: function (state) {
				flatten(state.elements).forEach(function (element) {
					return (element.selected = false);
				});
			},
		}; // CONCATENATED MODULE: ./reducers/reducers.ts

		var reducers_assign =
			(undefined && undefined.__assign) ||
			function () {
				reducers_assign =
					Object.assign ||
					function (t) {
						for (var s, i = 1, n = arguments.length; i < n; i++) {
							s = arguments[i];
							for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
						}
						return t;
					};
				return reducers_assign.apply(this, arguments);
			};

		/* harmony default export */ const reducers = reducers_assign(reducers_assign(reducers_assign(reducers_assign({}, creation), cursor), modifications_modifications), tools);

		/******/ return __webpack_exports__;
		/******/
	})();
});
